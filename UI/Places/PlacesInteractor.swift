//
//  PlacesInteractor.swift
//  Places
//
//  Created Sebastian Cancinos on 22/03/2020.
//  Copyright © 2020 sebacancinos. All rights reserved.
//
//  Template generated by Juanpe Catalán @JuanpeCMiOS
//

import UIKit
import CoreLocation

class PlacesInteractor: NSObject, PlacesInteractorInputProtocol {
    weak var presenter: PlacesInteractorOutputProtocol?
    var dataSource: PlacesProviderDataSource?
    let locationManager: CLLocationManager
    var currentLocation: CLLocationCoordinate2D?
    var selectedType: LocationType? = .restaurant
    var places: [Location]?

    private var reloadPending = false

    func loadLocations(by type: LocationType) {
        selectedType = type
        loadLocations()
    }

    func loadLocations() {
        guard let location = currentLocation else {
            reloadPending = true
            return
        }

        let strLocation = "\(location.latitude),\(location.longitude)"
        dataSource?.getPlaces(location: strLocation, radius: 5000, type: selectedType) {[weak self]  result in
            switch result {
            case .success(let locations):
                self?.reloadPending = false
                self?.places = locations
                self?.presenter?.present(locations: locations)

            case .failure(let error):
                self?.presenter?.present(error: error)
            }
        }
    }

    func loadNextLocations() {
        dataSource?.getNextPlaces(completionHandler: { [weak self]  result in
            switch result {
            case .success(let locations):
                self?.reloadPending = false
                if var places = self?.places {
                    places.append(contentsOf: locations)
                    self?.presenter?.present(locations: places)
                    self?.places = places
                }

            case .failure(let error):
                self?.presenter?.present(error: error)
            }
        })
    }

    func loadDetails(for location: Location) {
        dataSource?.getPlaceDetails(placeId: location.placeId) { [weak self]  result in
            switch result {
            case .success(let location):
                self?.presenter?.presentDetails(for: location)
            case .failure(let error):
                self?.presenter?.present(error: error)
            }
        }
    }

    override init() {
        self.locationManager = CLLocationManager()
        super.init()

        self.locationManager.requestWhenInUseAuthorization()

        if CLLocationManager.locationServicesEnabled() {
            locationManager.delegate = self
            locationManager.desiredAccuracy = kCLLocationAccuracyNearestTenMeters
            locationManager.startUpdatingLocation()
        }
    }
}

extension PlacesInteractor: CLLocationManagerDelegate {
    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        guard let location: CLLocationCoordinate2D = manager.location?.coordinate else { return }

        currentLocation = location

        if reloadPending {
            loadLocations()
        }
    }
}
